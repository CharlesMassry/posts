{"componentChunkName":"component---src-templates-blog-post-js","path":"/42-don-t-use-metaprogramming-when-you-can-just-throw-classes-at-things/","webpackCompilationHash":"d44b419ce58fd4452574","result":{"data":{"site":{"siteMetadata":{"title":"Charlie Massry","author":"Charlie Massry"}},"markdownRemark":{"id":"1fe018ad-e4aa-50c1-aa3d-2017124f54c0","excerpt":"Ruby has very powerful support for metaprogramming, which is also known as code that writes code, but it can be difficult to understand what is going on. One of…","html":"<p>Ruby has very powerful support for metaprogramming, which is also known as code that writes code, but it can be difficult to understand what is going on. One of the more obscure features of Object-Oriented Programming is the <a href=\"http://en.wikipedia.org/wiki/Singleton_pattern\">Singleton Pattern</a>, where you can add behavior to specific instances of classes and not all instances.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">x = &quot;wombat&quot;\ny = &quot;wobbegong&quot;\n\ndef x.foo\n  &quot;foo&quot;\nend\n\nx.foo # =&gt; &quot;foo&quot;\ny.foo # =&gt; NoMethodError: undefined method `foo&#39; for &quot;wobbegong&quot;:String</code></pre></div>\n<p>What’s going on here is you are defining <code class=\"language-text\">#foo</code> on the instance of String “wombat” but nothing else. When you define this method, internally Ruby is inserting a Singleton class with that method into the objects inheritance structure. When you call this method, Ruby doesn’t find it in the String class and it walks up the tree of inheritance till it either finds the method you called, or it calls <code class=\"language-text\">#method_missing</code> which defaults to raising that <code class=\"language-text\">NoMethodError</code> we saw earlier. This is not the only way to define Singleton methods.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">x = &quot;wombat&quot;\n\nx.define_singleton_method(:foo) do\n  &quot;foo&quot;\nend\n\nx.foo # =&gt; &quot;wombat&quot;</code></pre></div>\n<p>You can even do this to a bunch of instances all at once.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">module Animals\n  X = &quot;wombat&quot;\n  Y = &quot;wobbegong&quot;\n  Z = &quot;giant salamander&quot;\n\n  constants.each do |constant|\n    eval(constant.to_s).define_singleton_method(:foo) do\n      &quot;foo&quot;\n    end\n  end\nend</code></pre></div>\n<p><code class=\"language-text\">#each</code> is looking through every constant defined in the module and adding a singleton class <code class=\"language-text\">#foo</code> to them. The way the <code class=\"language-text\">.constants</code> method works is it grabs all of the constants as symbols, which won’t work on <code class=\"language-text\">#define_singleton_class</code>, so they must be evaluating with <code class=\"language-text\">eval</code>, which executes any piece of code. If you use eval to parse something a client can enter, you open yourself up to code injection, which is marginally worse than SQL injection.</p>\n<p>You could probably think of a few different ways to do this, such as opening up classes, which is also derogatorily called <a href=\"http://en.wikipedia.org/wiki/Monkey_patch\">Monkey Patching</a>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class String\n  def foo\n    &quot;foo&quot;\n  end\nend</code></pre></div>\n<p>Now every time you call <code class=\"language-text\">#foo</code> on any String instance, you get <code class=\"language-text\">&quot;foo&quot;</code>.</p>\n<p>While these features seem really cool, there really isn’t a great use for the Singleton Pattern here because we can just throw more classes at it.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Foo\n  attr_reader :string\n\n  def initialize(string)\n    @string = string\n  end\n\n  def foo\n    &quot;foo&quot;\n  end\n\n  def to_s\n    string\n  end\nend\n\nx = Foo.new(&quot;wombat&quot;)\nx # =&gt; wombat\nx.foo # =&gt; &quot;foo&quot;</code></pre></div>\n<p>The best parts about this is you can clearly see what is going on, and you can see that you didn’t break anything in any other classes.</p>\n<p>This is not to say don’t use metaprogramming, just don’t use it to take away clarity from what is going on.</p>","frontmatter":{"title":"Don't use Metaprogramming When You Can Just Throw Classes at Things","date":"October 28, 2014"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/42-don-t-use-metaprogramming-when-you-can-just-throw-classes-at-things/","previous":{"fields":{"slug":"/41-raw-sql-on-rails/"},"frontmatter":{"title":"Raw SQL on Rails","id":41}},"next":{"fields":{"slug":"/43-you-got-your-params-in-my-url/"},"frontmatter":{"title":"You Got Your Params in My URL","id":43}}}}}