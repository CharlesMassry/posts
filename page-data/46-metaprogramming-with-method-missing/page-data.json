{"componentChunkName":"component---src-templates-blog-post-js","path":"/46-metaprogramming-with-method-missing/","webpackCompilationHash":"ee13614abdca802b29ea","result":{"data":{"site":{"siteMetadata":{"title":"Charlie Massry","author":"Charlie Massry"}},"markdownRemark":{"id":"ad634073-a200-52ae-bd5f-799837014b07","excerpt":"In Ruby, you can extend the language significantly to suit your preferences, and even overide methods already used by the language itself. This is typically…","html":"<p>In Ruby, you can extend the language significantly to suit your preferences, and even overide methods already used by the language itself. This is typically derogatorily called Monkey Patching as I had covered <a href=\"http://www.charliemassry.com/posts/45-when-is-it-okay-to-monkey-patch\">previously</a>. One significant feature that I think all Ruby developers should know about is how the error <code class=\"language-text\">NoMethodError</code> gets generated. Because Ruby uses classical inheritance, all classes have ancestors. And as you may already know, everything in Ruby is an object, even classes are objects. Because of this, classes you create come with methods already defined on them. One method is called <code class=\"language-text\">#method_missing</code>. This very important method is defined on <code class=\"language-text\">BasicObject</code>, which is the first Ruby object, and all of its children get access to this method. The way Ruby uses this method is if a method is called on a Ruby object that doesn’t have that method defined, it calls <code class=\"language-text\">#method_missing</code> which walks up the chain of inheritance to <code class=\"language-text\">BasicObject</code> to see where <code class=\"language-text\">#method_missing</code> is defined. The way it is defined on <code class=\"language-text\">BasicObject</code> would look something like this if Ruby was written in Ruby.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class BasicObject\n  def method_missing\n  raise NoMethodError\n  end\nend</code></pre></div>\n<p>The reason why the language works like this is so you can override it and even dynamically create an API so you can override <code class=\"language-text\">#method_missing</code> Let’s say you wanted to write an API where the user can type in a camelcased number to access its index in an array.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Array\n  def method_missing(name)\n    index = EnglishNumber.word_to_number(name.to_s) - 1\n    self[index] || raise\n    rescue\n    super\n  end\nend</code></pre></div>\n<p>array = [1]\narray.one # => 1\narray.two # => NoMethodError undefined method ‘two’ for [1]:Array</p>\n<p>Let’s suppose that <code class=\"language-text\">EnglishNumber.word_to_number</code> takes a camelcased string, and converts it to a number. If you call a number on the array it will return the index or give a <code class=\"language-text\">NoMethodError</code>.</p>\n<p>When <code class=\"language-text\">#one</code> is called on an Array instance, the interpreter checks for <code class=\"language-text\">#one</code> and if it doesn’t find it, it then checks if <code class=\"language-text\">#method_missing</code> is defined, and if it is, it is called. This method, like all Ruby methods, can be overridden. In case there is no index on the array, you might want to throw an error, <code class=\"language-text\">self[index]</code> will return <code class=\"language-text\">nil</code> if the array doesn’t have that index. You can call <code class=\"language-text\">raise</code> to throw a generic error, but <code class=\"language-text\">rescue</code> will handle that error by passing it off up the chain of inheritance. This will make sure that you will get what you are expecting, as opposed to just getting nil, as that is very nondescript, and <code class=\"language-text\">NoMethodError</code> is very descriptive. While this can seem like a very contrived example, there are some very powerful libraries that take control of this feature such as ActiveRecord, specifically how <code class=\"language-text\">.find_by</code> worked in Rails 3.</p>\n<p>In Rails 3, there was no <code class=\"language-text\">.find_by</code> method but a <code class=\"language-text\">.find_by_#{attribute}</code> where attribute was defined by <code class=\"language-text\">#method_missing</code>. This was a very cool feature, but it can lead to a slowdown in performance as every time the Ruby interpreter has to call <code class=\"language-text\">#method_missing</code> and walk up the chain of inheritance. This code was removed for Rails 4 in favor of <code class=\"language-text\">.find_by(attribute: attribute)</code> for what I assume is slight performance gains.</p>\n<p>You can use <code class=\"language-text\">#method_missing</code> for some really cool programs, just be sure to stay out of trouble by using <code class=\"language-text\">super</code> to get its default behavior if the method doesn’t get what it wants.</p>","frontmatter":{"title":"Metaprogramming with Method Missing","date":"November 12, 2014"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/46-metaprogramming-with-method-missing/","previous":{"fields":{"slug":"/45-when-is-it-okay-to-monkey-patch/"},"frontmatter":{"title":"When Is It Okay to Monkey Patch?","id":45}},"next":{"fields":{"slug":"/47-reduce-your-sql-queries-with-a-counter-cache/"},"frontmatter":{"title":"Reduce Your SQL Queries With a Counter Cache","id":47}}}}}