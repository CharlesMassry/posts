{"componentChunkName":"component---src-templates-blog-post-js","path":"/36-using-redis-for-autocompletion-on-rails/","webpackCompilationHash":"ee13614abdca802b29ea","result":{"data":{"site":{"siteMetadata":{"title":"Charlie Massry","author":"Charlie Massry"}},"markdownRemark":{"id":"fcf32010-c096-5260-abd0-d26a634d086b","excerpt":"For a website that has search functionality, you might want to have autocompletion, so when the user starts typing it automatically pops up suggestions. This is…","html":"<p>For a website that has search functionality, you might want to have autocompletion, so when the user starts typing it automatically pops up suggestions. This is actually pretty tricky to implement because of a couple of reasons, namely performance. The actual Javascript function of getting the text to pop up is actually really easy if you use the <a href=\"http://jqueryui.com/autocomplete/\">JQuery-UI autocomplete</a> library.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$(function(){\n  $(&quot;#q&quot;).autocomplete({\n    source: &quot;/search_suggestions&quot;\n  });\n});</code></pre></div>\n<p>Your application would need to have a <code class=\"language-text\">/search_suggestion</code> path and JSON data at that path. The main question is how to model this data, specifically knowing that SQL queries can take a lot of time. Enter Redis.</p>\n<p><a href=\"http://www.redis.io\">Redis</a> is an in memory key-value store, which is exactly what we need. You can even try using Redis for free from <a href=\"http://try.redis.io/\">your browser</a> The idea is to take all the searchable items, make an AJAX request when the user types each letter and render the results as JSON.</p>\n<p>First you must setup Redis which is easy enough if you are on Mac OSX.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ brew install redis</code></pre></div>\n<p>Next you can start the Redis server in a separate terminal tab.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ redis-server</code></pre></div>\n<p>Once that is done you must configure Redis to work with Rails. Luckily, there’s a gem for that. In your Gemfile</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">gem &quot;redis&quot;</code></pre></div>\n<p>Then</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ bundle install</code></pre></div>\n<p>Now in <code class=\"language-text\">config/initializers/redis.rb</code> you can have Redis work globally by assigning the instance to a global variable like</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$redis = Redis.new</code></pre></div>\n<p>Since Redis is now configured, we must get Redis to work with the search suggestions.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class SearchSuggestion\n  def self.terms_for(prefix)\n    $redis.zrevrange(&quot;search-suggestion:#{prefix.downcase}&quot;, 0, 9)\n  end\nend</code></pre></div>\n<p>In controller you can just render the model as JSON.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class SearchSuggestionsController &lt; ApplicationController\n  def index\n    render json: SearchSuggestion.terms_for(params[:term])\n  end\nend</code></pre></div>\n<p>Nothing will be displayed however right now as <code class=\"language-text\">#zrevrange</code> is equivalent to a <code class=\"language-text\">SELECT</code> statement. So to insert the data, I recommend writing a rake task to index the terms, as you don’t want to have Rails process all of the indexing and get hung up.</p>\n<p>You can write a rake task by creating a file in the <code class=\"language-text\">lib/tasks</code> directory ending in <code class=\"language-text\">.rake</code>, we’ll call it <code class=\"language-text\">search_suggestion.rake</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">namespace :search_suggestions do\n  desc &quot;Generate search suggestions from location&quot;\n  task index: :environment do\n    SearchSuggestion.index_location\n  end\nend</code></pre></div>\n<p>Now when you type in <code class=\"language-text\">$ rake -T</code> you will see your rake task on the rake task list. You can run this task by simply typing</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ rake search_suggestions:index</code></pre></div>\n<p>Now how do we form that <code class=\"language-text\">.index_location</code> class method. We can take all of the locations and index each of them by their combined letters up to but not including their last letter. We also want to make each individual word indexed by its letters.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def self.index_locations\n  Location.find_each do |location|\n    index_term(location.name)\n    location.name.split.each { |term| index_term(term) }\n  end\nend\n\ndef self.index_term(term)\n  1.upto(term.length - 1) do |n|\n    prefix = term[0, n]\n    $redis.zincrby(&quot;search-suggestion:#{prefix.downcase}&quot;, 1, term.downcase)\n  end\nend</code></pre></div>\n<p>The entire location name is being indexed in the <code class=\"language-text\">.index_term</code> method, and then the individual words are being indexed.</p>\n<p>This will be much faster than just using <code class=\"language-text\">SQL</code> queries, but you still probably want to squeeze out that last bit of performance. Well there is a way that involves modifying the Rack Middleware. If you’re not familiar with Rack Middleware, what happens when a request comes to your Rails application, the request passes through the Rack Middleware and each piece of Middleware changes the request on the way down until it finally reaches your application. We will want to change this because each piece of Middleware can add some time to the request. First, we must create the Middleware we want to add. We can make a new directory called <code class=\"language-text\">app/middleware</code>. In this directory we can make the Middleware file <code class=\"language-text\">search_suggestions.rb</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class SearchSuggestions\n  def initialize(app)\n    @app = app\n  end\n\n  def call(env)\n    if env[&quot;PATH_INFO&quot;] == &quot;/search_suggestions&quot;\n      request = Rack::Request.new(env)\n      terms = SearchSuggestion.terms_for(request.params[&quot;term&quot;])\n      [200, {&quot;Content-Type&quot; =&gt; &quot;application/json&quot;}, [terms.to_json]]\n    else\n      @app.call(env)\n    end\n  end\nend</code></pre></div>\n<p>Each Middleware is initialized with the Application object and each middleware uses the <code class=\"language-text\">#call</code> method on the Application. This is a form of polymorphism as all each Middleware must do is respond to <code class=\"language-text\">#call</code>. Here the request is instantiated with the Application object and the <code class=\"language-text\">params[&quot;term&quot;]</code> is extracted to call the search suggestion. The result is then sent back to the client as JSON. To add the Middleware to the top of the stack, you want to go into <code class=\"language-text\">config/application.rb</code>, and inside of the Application class, add</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">config.middleware.insert_before(0, &quot;SearchSuggestions&quot;)</code></pre></div>\n<p>This inserts the middleware at the front, and now you are all setup with fast autocompletion. There is still some CSS issues that you will run into as the JQuery-UI autocomplete doesn’t add any CSS, but I’ll leave that to you.</p>","frontmatter":{"title":"Using Redis for Autocompletion on Rails","date":"September 30, 2014"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/36-using-redis-for-autocompletion-on-rails/","previous":{"fields":{"slug":"/35-google-maps-on-rails/"},"frontmatter":{"title":"Google Maps on Rails","id":35}},"next":{"fields":{"slug":"/37-don-t-use-your-mouse-for-text-editing-with-vim/"},"frontmatter":{"title":"Don't Use Your Mouse for Text Editing with Vim","id":37}}}}}