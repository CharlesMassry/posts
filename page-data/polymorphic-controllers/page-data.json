{"componentChunkName":"component---src-templates-blog-post-js","path":"/polymorphic-controllers/","webpackCompilationHash":"","result":{"data":{"site":{"siteMetadata":{"title":"Charlie Massry","author":"Charlie Massry"}},"markdownRemark":{"id":"a70dd67f-d47a-5b57-aa4c-3fb33c3f0d50","excerpt":"That’s right, polymorphic controllers in Ruby on Rails. You made your model polymorphic, but now you would have to make a controller for each use case of the…","html":"<p>That’s right, polymorphic controllers in Ruby on Rails. You made your model polymorphic, but now you would have to make a controller for each use case of the association. But what if I told you that you can simply make your one controller function for each of the different associations. I say simply, but it can actually become quite complex as you have to get the correct model depending on how the URL looks and turn that string into a constant and then find the correct record.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class HatesController &lt; ApplicationController\n  def create\n    this_route = request.fullpath\n    this_route.sub!(/\\\\/comments.*|\\\\/hate/, &#39;&#39;)\n    Hate.create(user: current_user, hateable: hateable)\n    redirect_to this_route\n  end\n  ...\n  private\n\n  def hateable\n    route_to_hate = request.fullpath\n    klass = [&quot;comments&quot;, &quot;images&quot;, &quot;galleries&quot;, &quot;groups&quot;, &quot;users&quot;].detect do |k|\n      route_to_hate.include?(k)\n    end\n    klass.singularize.classify.constantize.find(params[:id])\n  end\nend</code></pre></div>\n<p>There is a lot going on in this controller. First, in the hateable method, it gets the URL and detects which model the user is hating, and returns just the first one it finds. For nested resources you must put the deepest one at the front. Once it gets the correct string, it then must turn it into the model by calling classify on the string, which makes the string into a camelcased string. Next up is constantize, which turns that camelcased string into an actual model call. Then it just finds by the id in the params hash.</p>\n<p>The next issue is the create method, which gets the path and scrubs it to something that exists as an actual <code class=\"language-text\">GET</code> route, using a fairly complex regular expression. What this regular expression <code class=\"language-text\">/\\\\/comments.*|\\\\/hate/</code> is doing is it is getting the comments path if the word comments is in the path, then it gets the slash and the digits, but it will always get the word hate for the purposes of this controller action. This is necessary to know where to redirect the user to. It then creates the hate by using <code class=\"language-text\">@hateable</code> from earlier, and redirects to the afformentioned route.</p>\n<p>Depending on your type of path and resource you may have to change the way you get the model from the route but it can be done with much less code then making a seperate controller for each polymorphic relationship.</p>","frontmatter":{"title":"Polymorphic Controllers???","date":"July 21, 2014"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/polymorphic-controllers/","previous":{"fields":{"slug":"/polymorphism-very-difficult-or-suprisingly-simple/"},"frontmatter":{"title":"Polymorphism, Very Difficult? Or Suprisingly Simple?","id":20}},"next":{"fields":{"slug":"/javascript-on-rails/"},"frontmatter":{"title":"Javascript on Rails","id":22}}}}}