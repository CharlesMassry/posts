{"componentChunkName":"component---src-templates-blog-post-js","path":"/52-caching-rails-views/","webpackCompilationHash":"d44b419ce58fd4452574","result":{"data":{"site":{"siteMetadata":{"title":"Charlie Massry","author":"Charlie Massry"}},"markdownRemark":{"id":"45acfd52-0aaa-58c8-a1f6-c5829c30569d","excerpt":"“There are only two hard things in Computer Science: cache invalidation, naming things, and off-by-one errors.” Fortunately for us, Rails makes caching quite…","html":"<p>“There are only two hard things in Computer Science: cache invalidation, naming things, and off-by-one errors.” Fortunately for us, Rails makes <a href=\"http://guides.rubyonrails.org/caching_with_rails.html\">caching</a> quite simple.</p>\n<p>In your log files you might notice that the views take a lot longer to process than you might hope, but you can cache them easily. To get started in <code class=\"language-text\">config/development.rb</code> add the line <code class=\"language-text\">config.action_controller.perform_caching = true</code>.</p>\n<p>Now, you can cache any ActiveRecord partial and it automatically expires when the <code class=\"language-text\">updated_at</code> column changes.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;% cache post do %&gt;\n  &lt;%= div_for post do %&gt;\n    &lt;h3&gt;&lt;%= link_to post.title, post %&gt;&lt;/h3&gt;\n    &lt;p&gt;&lt;%= truncate(post.text, length: 160, separator: &#39;.&#39;) %&gt;&lt;/p&gt;\n    &lt;p&gt;&lt;%= display_time(post) %&gt; on &lt;% post. tags.each do |tag| %&gt;\n      &lt;%= link_to capitalize_tag(tag.name), tag_path(tag.name) %&gt;\n    &lt;% end %&gt;\n    &lt;%= post.comments_count %&gt;\n  &lt;% end %&gt;\n&lt;% end %&gt;</code></pre></div>\n<p>Because <code class=\"language-text\">#comments_count</code> is part of an association, we must update the comments model so the post gets updated whenever anyone comments on it.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Comment &lt; ActiveRecord::Base\n  belongs_to :post, counter_cache: true, touch: true\nend</code></pre></div>\n<p>By adding <code class=\"language-text\">touch: true</code> whenever anyone comments on the post, the post will get updated.</p>\n<p>You can even add caches to static fragment views easily like say a navigation bar partial. Just wrap it in a <code class=\"language-text\">cache</code> block. You can specify which version of the cache you want as the argument, <code class=\"language-text\">&lt;% cache &#39;v1&#39; do %&gt;</code>.</p>\n<p>One downside of this fragment caching is that when the partial gets updated it will take longer to render the first time because it must write the file to the filesystem and then read it, but every subsequent view will be significantly faster. For something that gets updated quite frequently, consider foregoing fragment caching, as this performance hit on updating the cache can be too big.</p>\n<p>When you are finished with this feature, go ahead and set <code class=\"language-text\">config.action_controller.perform_caching = false</code> in <code class=\"language-text\">config/development.rb</code>. It is automatically true on production, but can be a pain during development. With view caching, your performance can be greatly improved by having the views already generated, and you’ll get a really nice boost in performance.</p>","frontmatter":{"title":"Caching Rails Views","date":"January 13, 2015"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/52-caching-rails-views/","previous":{"fields":{"slug":"/51-advanced-searching-with-sql/"},"frontmatter":{"title":"Advanced Searching With SQL","id":51}},"next":{"fields":{"slug":"/53-building-a-blog-reader-in-ios-part-1/"},"frontmatter":{"title":"Building a Blog Reader in iOS, Part 1","id":53}}}}}