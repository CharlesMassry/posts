{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/53-building-a-blog-reader-in-ios-part-1/","webpackCompilationHash":"9bd9275ec41b64705887","result":{"data":{"site":{"siteMetadata":{"title":"Charlie Massry","author":"Charlie Massry"}},"markdownRemark":{"id":"7c119204-16b8-5662-8502-5564b06c16ae","excerpt":"In this post, we will be building an app that retrieves a collection from the web and view it as a table. The data is an index of my blog posts and can be found…","html":"<p>In this post, we will be building an app that retrieves a collection from the web and view it as a table. The data is an index of my blog posts and can be found at <a href=\"http://www.charliemassry.com/posts.json\">http://www.charliemassry.com/posts.json</a>.</p>\n<p><img src=\"http://i.imgur.com/pjJPsnE.png\" alt=\"finishedTableViewController\"></p>\n<p>To accomplish this we will need a way to render each cell in this table and fetch the data from the JSON feed. Luckily for use, this table view is a default in iOS development and there is a easy library to use for the fetching of the JSON feed called <a href=\"http://afnetworking.com/\">AFNetworking</a>.</p>\n<p>To begin, open up Xcode and create a new app. For this app we will simply use the single view application for learning purposes.</p>\n<p>In the <code class=\"language-text\">application:didFinishLaunchingWithOptions:</code> method in our <code class=\"language-text\">AppDelegate.m</code> file, there is some boilerplate code we must add to get started.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">UINavigationController *navController = [[UINavigationController alloc] init];\nself.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];\nself.window.rootViewController = navController;\n[self.window makeKeyAndVisible];  </code></pre></div>\n<p>This seems like a lot, but all this does is make a navigation controller the main controller of the application. When you compile and run the code, you will simply see a main screen that is black. Now how will we get the table?</p>\n<p>We must create the table view controller. In the menu, simply click on File > New > File. When prompted, make the new file a subclass of the <code class=\"language-text\">UITableViewController</code> and lets call it, <code class=\"language-text\">PostsTableViewController</code>.</p>\n<p>First we must initialize the posts in the interface.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">@property (strong, nonatomic) NSArray *posts;</code></pre></div>\n<p>In a table view, there are a few things you need to be aware of. There are properties like title, number of sections, and number of cells per section. In the <code class=\"language-text\">viewDidLoad</code> method, add the line <code class=\"language-text\">self.title = @&quot;Blog&quot;;</code> to add the title to the view. In the <code class=\"language-text\">numberOfSectionsInTableView:</code> method, you can set how many sections there are in the table by its return value; for this, just <code class=\"language-text\">return 1;</code>. The <code class=\"language-text\">tableView:numberOfRowsInSection:</code> method behaves similarly, although this one describes the number of cells in each section; <code class=\"language-text\">return 20;</code> for now.</p>\n<p>We now have to give the cells data, and we can do this in the <code class=\"language-text\">tableView:cellForRowAtIndexPath:</code> method.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {\n    UITableViewCell *cell = [tableView\n        dequeueReusableCellWithIdentifier:@&quot;cell&quot;];\n\n    if (cell == nil) {\n        cell = [[UITableViewCell alloc]\n            initWithStyle:UITableViewCellStyleDefault\n            reuseIdentifier:@&quot;cell&quot;];\n    }\n    cell.textLabel.text = @&quot;banana&quot;;\n    return cell;\n}</code></pre></div>\n<p>This method can be very confusing. What we are doing is initializing a table cell and giving it a string to see if we can reuse the particular cell. The reason why we want to do this is to prevent a memory leak. Basically everytime you scroll up and down on a table view, it must recreate every table view cell and they won’t be freed from memory. There will always be a fixed number of table view cells, but they will each have different properties such as the title. To fix this you can give it a reusable identifier to know if it has been created. Either way, with this code, it will always give the display text of <code class=\"language-text\">&quot;banana&quot;</code>.</p>\n<p>That’s a great start but we want to have it display a feed of data from the web, specifically a collection of posts. We can do this by creating a post model and have it loop over a collection of posts and displaying the title individually.</p>\n<p>Let’s create a new <code class=\"language-text\">Post</code> model and have it inherit from <code class=\"language-text\">NSObject</code>. Next we will want to give it the title, text, id, and comments count properties in the interface.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">@interface Post : NSObject\n    @property(strong, nonatomic)NSString *title;\n    @property(strong, nonatomic)NSString *text;\n    @property(strong, nonatomic)NSNumber *idNo;\n    @property(strong, nonatomic)NSNumber *commentsCount;\n@end</code></pre></div>\n<p>Because we will be getting data from the web in the form of a JSON feed, we should create a method to populate it with data. Objective-C has a class called NSDictionary which is almost identical to a Hash in Ruby or a JavaScript Object, but you won’t have to worry about JSON parsing with AFNetworking. We should create this method called <code class=\"language-text\">initWithDictionary:</code> that takes an NSDictionary, creates the relevent fields, and returns itself.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-(id)initWithDictionary:(NSDictionary *)json {\n    self = [super init];\n    self.title = json[@&quot;title&quot;];\n    self.text = json[@&quot;text&quot;];\n    self.idNo = json[@&quot;id&quot;];\n    self.commentsCount = json[@&quot;comments_count&quot;];\n    return self;\n}</code></pre></div>\n<p>This will make our lives much easier very shortly.</p>\n<p>Now we must get this data from the web, populate it in the model, and then display it in the view. This is perfect for AFNetworking to handle. To handle dependencies easily, we can use Cocoapods. Like RubyGems, Cocoapods lets you easily keep track of your external dependencies.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ gem install cocoapods\n$ pod setup\n$ pod init</code></pre></div>\n<p>In the Podfile we just created, we want to list our dependencies.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target &#39;Blog&#39; do\n    source &#39;https://github.com/CocoaPods/Specs.git&#39;\n    platform :ios, &#39;~&gt; 7.0&#39;\n    pod &#39;AFNetworking&#39;, &#39;~&gt; 2.4&#39;\nend</code></pre></div>\n<p>Be sure to close Xcode and open it up through the <code class=\"language-text\">.xcworkspace</code> file for CocoaPods to work.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ open Blog.xcworkspace  </code></pre></div>\n<p>Now how will we fetch that data, I propose creating a separate client to better organize your code as you don’t want your model to be responsible for making web requests. Let’s make a new file called <code class=\"language-text\">PostClient</code> which also inherits from <code class=\"language-text\">NSObject</code>. Let’s make a class method called <code class=\"language-text\">getPosts</code>, which gets posts and creates an array of posts. Also we might want to define a base <code class=\"language-text\">PostURL</code> for reuse later.</p>\n<p>First be sure to add the two dependencies’ header files that you’ll need, <code class=\"language-text\">AFNetworking</code> and <code class=\"language-text\">Post</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#import &quot;AFNetworking.h&quot;\n#import &quot;Post.h&quot;</code></pre></div>\n<p>Then define the base <code class=\"language-text\">postURL</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">NSString *const postURL = @&quot;http://www.charliemassry.com/posts&quot;;</code></pre></div>\n<p>Now for the method implementation.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">+(void)getPosts {\n    NSString *postIndexURL = [postURL stringByAppendingString:@&quot;.json&quot;];\n    AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];\n    [manager GET:postIndexURL\n        parameters:nil\n        success:^(AFHTTPRequestOperation *operation, id JSON) {\n        NSMutableArray *tmpPosts = [[NSMutableArray alloc] init];\n            for (NSDictionary *tmpDictionary in JSON) {\n                Post *tmpPost = [[Post alloc] initWithDictionary:tmpDictionary];\n                [tmpPosts addObject:tmpPost];\n            }\n        NSArray *posts = [[NSArray alloc] initWithArray:tmpPosts];\n        [[NSNotificationCenter defaultCenter]\n            postNotificationName:@&quot;postIndexFinishedLoading&quot;\n            object:posts];\n        } failure:^(AFHTTPRequestOperation *operation, NSError *error) {\n            NSLog(@&quot;Error: %@&quot;, error);\n        }];\n}</code></pre></div>\n<p>I’ll take this one step at a time. First we are getting the constant and adding a <code class=\"language-text\">.json</code> to the end of it. This is because when we go later to make the request for each post individually, we won’t have to write the route again, and we won’t leave any room for error. We then initialize the AFNetworking request and send the method <code class=\"language-text\">GET:parameters:success:failure:</code>. <code class=\"language-text\">GET</code> is the URL, the parameters is nil because it is a simple GET request, but there is that weird caret for <code class=\"language-text\">success:</code> and <code class=\"language-text\">failure:</code>. This the Objective-C syntax for a block or anonymous function. The <code class=\"language-text\">success:</code> block is what it does with a successful web response, and you can see that it has the JSON parameter, which is your JSON feed and is either an NSDictionary or NSArray, depending on the request. In this case it is an NSArray of NSDictionaries. If you are familiar with making AJAX calls using jQuery, this should click for a couple of reasons; the parameters that need to be passed in are the same and it is done asynchronously.</p>\n<p>Inside of your success block, you have access to the JSON feed, and you’ll want to create an NSArray of posts using it. Because NSArrays are immutable, meaning once created they can not be modified, like appending or poping, you must initialize the NSArray after you’ve already built a temporary one using an NSMutableArray. So you’ll loop through the JSON feed, create a post, and add it to the temporary array. Once that’s done it will create the NSArray. Then a really tricky thing happens. Because of the way iOS works, it doesn’t leave you hanging on a web request, it runs the code asynchronously and the web response is not immediate, so you must give it a way to hook into your <code class=\"language-text\">PostTableViewController</code>. Fortunately this works pretty easily with <code class=\"language-text\">NSNotificationCenter</code>. You send the message <code class=\"language-text\">postNotificationName:object:</code> where the postNotificationName is a string that the controller will be listening for and the object is the object you just created. That’s it for the <code class=\"language-text\">PostClient</code>, all we have left is to tell the controller to execute this code and listen for the response.</p>\n<p>In the controller, in the <code class=\"language-text\">viewDidLoad</code> method, we will call this class method we just created to get the posts from the <code class=\"language-text\">PostClient</code> and we will have it listen for the <code class=\"language-text\">&quot;postIndexFinishedLoading&quot;</code> notification.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[super viewDidLoad];\n[PostClient getPostIndex];\n[[NSNotificationCenter defaultCenter]\n    addObserver:self\n    selector:@selector(dataRetrieved:)\n    name:@&quot;initWithJSONFinishedLoading&quot;\n    object:nil];</code></pre></div>\n<p>In <code class=\"language-text\">viewDidLoad</code> in the <code class=\"language-text\">PostTableViewController</code>, after we call <code class=\"language-text\">[super viewDidLoad];</code> we have the <code class=\"language-text\">PostClient</code> begin fetching the data from the server. It then listens for the message and calls the <code class=\"language-text\">dataRetrieved:</code> method that we have yet to implement.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-(void)dataRetrieved:(NSNotification *)retrievedPosts; {\n    self.posts = [retrievedPosts object];\n    [self.tableView reloadData];\n}</code></pre></div>\n<p>This method gets called with the object that had been passed in to it when the <code class=\"language-text\">success:</code> block finished, so the <code class=\"language-text\">retrievedPosts</code> variable is a <code class=\"language-text\">NSNotification</code> instance, but when you send it the message <code class=\"language-text\">object</code> it returns whatever object that had been passed in. Next you <strong>MUST</strong> tell the table to reload its data or you will never see the posts again.</p>\n<p>After all of this you should see your posts displaying and scrollable. Stay tuned for a future post when I go over how to select a post to be displayed individually.</p>","frontmatter":{"title":"Building a Blog Reader in iOS, Part 1","date":"January 30, 2015"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/53-building-a-blog-reader-in-ios-part-1/","previous":{"fields":{"slug":"/posts/52-caching-rails-views/"},"frontmatter":{"title":"Caching Rails Views","id":52}},"next":{"fields":{"slug":"/posts/54-building-a-blog-reader-in-ios-part-2/"},"frontmatter":{"title":"Building a Blog Reader in iOS, Part 2","id":54}}}}}