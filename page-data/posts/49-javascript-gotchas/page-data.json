{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/49-javascript-gotchas/","webpackCompilationHash":"6906578f74f2bac6e1b0","result":{"data":{"site":{"siteMetadata":{"title":"Charlie Massry","author":"Charlie Massry"}},"markdownRemark":{"id":"3790ef77-1bbe-5b71-b2aa-1bf3dbc3e0c6","excerpt":"Coming from Ruby, Javascript can be quite intimidating for a couple of reasons, mainly focused on the object system that it implements. While Javascript is an…","html":"<p>Coming from Ruby, Javascript can be quite intimidating for a couple of reasons, mainly focused on the object system that it implements. While Javascript is an Object Oriented Language, it does not use classical inheritance, but instead uses <a href=\"http://en.wikipedia.org/wiki/Prototype-based_programming\">Prototypical Inheritance</a>, this means that all objects are actually clones of other objects and there is no abstract representation of classes. There are also a few different ways to define an object in Javascript. You can define it in the same way that you would a Ruby hash.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var person = {};</code></pre></div>\n<p>This is now an object and you can add properties to it.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">person.firstName = &quot;Charlie&quot;;</code></pre></div>\n<p>This is interesting but this doesn’t seem very Object Oriented as you can imagine this can lead to code duplication as you’ll have to add each property as a separate statement. Another way to create an Object is to define it as a function and make instances of that prototype.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function Person (firstName) {\n  this.firstName = firstName;\n};\n\nvar person = new Person(&quot;Charlie&quot;);\nperson.firstName; //=&gt; &quot;Charlie&quot;</code></pre></div>\n<p>This looks much better as you are able to define properties on this prototype.</p>\n<p>What if we wanted to add functions to this object? We can do that too.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function Person (firstName) {\n  this.firstName = firstName;\n  this.sayHello = function() {\n    return &quot;Hello&quot;\n  };\n};\n\nvar person = new Person(&quot;Charlie&quot;);\nperson.firstName; //=&gt; &quot;Charlie&quot;\nperson.sayHello(); //=&gt; &quot;Hello&quot;</code></pre></div>\n<p>Note the sayHello is a function and unlike Ruby, there is a differentiation between properties and functions so for <code class=\"language-text\">person.firstName</code> we didn’t have to add parenthesis to the end but we had to for the function <code class=\"language-text\">person.sayHello()</code>.</p>\n<p>What if we had a bunch of functions that shouldn’t really be part of the public API for the class. We’d want to create private methods like we would in Ruby, right? Not so fast, Javascript doesn’t have the notion of private functions, but we can still acheive this through some trickery.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function Person (firstName) {\n  this.firstName = firstName;\n  this.sayHello = function() {\n    return hello();\n  };\n  var hello = function(){ return &quot;Hello&quot; };\n};\n\nvar person = new Person(&quot;Charlie&quot;);\nperson.firstName; //=&gt; &quot;Charlie&quot;\nperson.sayHello(); //=&gt; &quot;Hello&quot;\nperson.hello(); //=&gt; &quot;Uncaught TypeError: undefined is not a function&quot;</code></pre></div>\n<p>By not binding <code class=\"language-text\">hello()</code> to the <code class=\"language-text\">this</code> keyword, we can leverage Javascript’s scope to make it not accessible outside the object. This is different from a language like Ruby where you must declare methods that are private explicitly or Objective C where you must declare methods publicly.</p>\n<p>Now that that is settled, how do we call these properties? Properties and functions can be called with either dot notation or bracket notation.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">person.firstName; // dot notation\nperson[&quot;firstName&quot;]; // bracket notation\n\nperson.sayHello(); // dot notation\nperson[&quot;sayHello&quot;](); // bracket notation</code></pre></div>\n<p>The bracket notation looks like Ruby’s hash calling syntax but when you use it to call a function, I think we can all agree that it just looks ugly. If you want to make a dynamic call however, you must use the bracket notation.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var numbers = {\n  &quot;1&quot;: &quot;One&quot;,\n  &quot;2&quot;: &quot;Two&quot;,\n  &quot;3&quot;: &quot;Three&quot;,\n  &quot;4&quot;: &quot;Four&quot;,\n  &quot;5&quot;: &quot;Five&quot;,\n  &quot;6&quot;: &quot;Six&quot;,\n  &quot;7&quot;: &quot;Seven&quot;,\n  &quot;8&quot;: &quot;Eight&quot;,\n  &quot;9&quot;: &quot;Nine&quot;\n};\n\nvar num = parseInt(Math.random() * (9 - 1) + 1);\nnum //=&gt; 3\nnumbers.num; //=&gt; undefined\nnumbers[num]; //=&gt; &quot;Three&quot;</code></pre></div>\n<p>A good way to demonstrate what is happening is to test it’s equality.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">numbers.num === numbers[&quot;num&quot;]; //=&gt; true</code></pre></div>\n<p>If you actually think about this example, it shouldn’t even work because the key is supposed to be the string 3 and not the integer 3, but Javascript is not one for complaining about typing.</p>\n<p>Testing equality in Javascript can also be a task that’ll leave you scratching your head. Most programming languages use one equal sign for assignment and two for equality, but Javascript uses two and three for equality. Unfortunately, it isn’t always consistent knowing what is going to return true.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1 == 1; //=&gt; true\n1 == &quot;1&quot;; //=&gt; true\n1 === &quot;1&quot;; //=&gt; false\ntrue == &quot;true&quot;; //=&gt; false\n[] == {}; //=&gt; false\n{} == []; //=&gt; Uncaught SyntaxError: Unexpected token ==\n{} === {}; //=&gt; Uncaught SyntaxError: Unexpected token ===</code></pre></div>\n<p>As a rule, you always want to use the triple equals sign for equality checking as the double equal sign sometimes casts the values to strings. True is not cast to a string, and while clearly an array is not the same thing as a literal object, you can’t check the equality of a literal object. You can however test equality after assignment for a literal object.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var number = {};\nvar something = {};\nnumber == something; //=&gt; false\nnumber === something; //=&gt; false</code></pre></div>\n<p>Another issue with Javascript’s object system is it’s Numeric prototype. In a lot of languages you have a number system where numbers can be either floats or integers. In static languages such as C++, the type must be declared when it is initialized so you must call it either a float or an integer. In dynamic languages such as Ruby, you can declare it literally, <code class=\"language-text\">x = 3</code> is an integer, but <code class=\"language-text\">x = 3.0</code> is a float. It does get converted in Ruby to the proper type if you need it.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">3 * 3.0 # =&gt; 9.0\n3.0 + 3 # =&gt; 6.0</code></pre></div>\n<p>In Javascript, there are no floats and integers, only numbers, which means when I called <code class=\"language-text\">parseInt()</code> up there to get a random number, it essentially just choped off the decimal place. This can lead to a gotcha if you need to match a number as a string from Ruby to Javascript. If you send a float in as JSON in Ruby that looks like <code class=\"language-text\">9.0</code>, Javascript would convert that to just a <code class=\"language-text\">9</code> because it chops of the decimal place when it sees that. To solve this issue you can make it a string on Ruby’s end so you don’t have to worry about it with Javascript. If you remember these features of Javascript, they can save you a lot of issues down the road.</p>","frontmatter":{"title":"Javascript Gotchas","date":"January 06, 2015"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/49-javascript-gotchas/","previous":{"fields":{"slug":"/posts/48-how-to-debug-rails-apps/"},"frontmatter":{"title":"How to Debug Rails Apps","id":48}},"next":{"fields":{"slug":"/posts/50-getting-started-with-objective-c/"},"frontmatter":{"title":"Getting Started With Objective C","id":50}}}}}