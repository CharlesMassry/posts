{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/51-advanced-searching-with-sql/","webpackCompilationHash":"8ad048b9041a01a887b8","result":{"data":{"site":{"siteMetadata":{"title":"Charlie Massry","author":"Charlie Massry"}},"markdownRemark":{"id":"96573c88-abe6-580e-9f35-9957acf6131f","excerpt":"Over on the left, you see that there is a nice little search box to search through my posts. When you search for something you might notice the way that the…","html":"<p>Over on the left, you see that there is a nice little search box to search through my posts. When you search for something you might notice the way that the posts are ordered are very helpful. This is because when you search, the results are sorted by the title of the post and then by the text. Implementing this was rather difficult as I had bounced around between a couple of solutions. My original solution was this.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def self.search(query)\n  text = search_text(query).select(:id)\n  title = search_title(query).select(:id)\n  results = title + text\n  results.map do |result|\n    find(result)\n  end\nend\n\ndef self.search_title(query)\n  where(&quot;title LIKE ?&quot;, &quot;%#{query}%&quot;)\nend\n\ndef self.search_text(query)\n  where(&quot;text LIKE ? AND title NOT LIKE ?&quot;, &quot;%#{query}%&quot;, &quot;%#{query}%&quot;)\nend</code></pre></div>\n<p>This code is not great for a couple of reasons. First, you must use class methods for everything because of Ruby scoping, and making class methods private in Ruby is a <a href=\"http://blog.roberteshleman.com/2014/08/22/private-class-methods-in-ruby/\">hassle</a>. Second, It is a very inefficient search because it makes 2 original queries and then one additional query for every result that the first 2 queries found. This can be bad for performance if you have a lot of blog posts. Configuring this search for pagination is a little confusing because <a href=\"https://github.com/amatsuda/kaminari\">kaminari</a> isn’t setup for arrays as default but an ActiveRecord Relation. Also, the way ActiveRecord works is when you are chaining the queries it builds up the query and then executes as opposed to executing sequentially.</p>\n<p>One solution I came up with is to use a searching gem like Solr or ElasticSearch. This can be a difficult to set up and requires additional resources. Also, if you have anything against Java or the JVM, these solutions are not for you. Solr has it’s problems of configuration because it treats different data types differently even if they both contain characters. ElasticSearch has it’s problems of the default gem to integrate it into a Rails app has a terrible API. Both of these solutions however do allow you to boost the results depending on the column.</p>\n<p>The SQL solution to this problem is to use weighted searches. While not built into SQL you can add if statements to SQL and create a separate column in SQL on the fly.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT *,\n  IF(title LIKE &#39;%ruby%&#39;, 20, 0) AS weight\n  FROM `posts`\n  WHERE (title LIKE &#39;%ruby%&#39; OR text LIKE &#39;%ruby%&#39;)\n  ORDER BY weight DESC;</code></pre></div>\n<p>This is how you would write a query in SQL that does this. Notice the syntax in the if statement, it’s saying if the title matches <code class=\"language-text\">%ruby%</code>, then put a 20 in the weight column, otherwise put a 0. Once it does this it then filters by the <code class=\"language-text\">WHERE</code> clause and orders it by weight. Now that that’s out of the way, how do you integrate this solution into a Rails app using ActiveRecord. <a href=\"http://www.charliemassry.com/posts/41-raw-sql-on-rails\">Previously</a>, I had talked about how to write raw SQL using ActiveRecord but there must be a more elegant solution for this issue, right? Well there is, but there is still the issue of figuring out how to write it.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Post.select(&quot;*, IF(title LIKE ? , 20, 0) AS weight&quot;, &quot;%#{query}%&quot;).\n  where(&quot;title LIKE ? OR text LIKE ?&quot;, &quot;%#{query}%&quot;, &quot;%#{query}%&quot;).\n  order(&quot;weight DESC&quot;)</code></pre></div>\n<p>This was my initial idea because it’s using the <code class=\"language-text\">SELECT</code> statement to create the additional column. This won’t work because the <code class=\"language-text\">?</code> the query afterwards to properly escape it only works for the <code class=\"language-text\">where</code> method and not just any SQL. The way around this is to just drop it in instead of the <code class=\"language-text\">?</code>. You must escape it because it’d be a shame if anyone was to drop your database using SQL injection. Luckily there is a class method on ActiveRecord::Base that sanitizes inputs for SQL.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Post.select(&quot;*, IF(title LIKE #{sanitize(&quot;%#{query}%&quot;)}, 20, 0) AS weight&quot;).\n  where(&quot;title LIKE ? OR text LIKE ?&quot;, &quot;%#{query}%&quot;, &quot;%#{query}%&quot;).\n  order(&quot;weight DESC&quot;)</code></pre></div>\n<p>This is the final ActiveRecord query that is used and while it doesn’t read too elegantly, it works, and is much more maintainable and better performant than my original solution when you don’t want to add additional dependencies.</p>","frontmatter":{"title":"Advanced Searching With SQL","date":"January 09, 2015"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/51-advanced-searching-with-sql/","previous":{"fields":{"slug":"/posts/50-getting-started-with-objective-c/"},"frontmatter":{"title":"Getting Started With Objective C","id":50}},"next":{"fields":{"slug":"/posts/52-caching-rails-views/"},"frontmatter":{"title":"Caching Rails Views","id":52}}}}}