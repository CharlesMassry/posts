{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/25-ruby-enumerable-part-2/","webpackCompilationHash":"6906578f74f2bac6e1b0","result":{"data":{"site":{"siteMetadata":{"title":"Charlie Massry","author":"Charlie Massry"}},"markdownRemark":{"id":"8021a184-2092-5cc2-9a93-02f5c5b04d02","excerpt":"The Enumerable module can be used for all of your Ruby classes as long as they implement their own each method. A good example of this are the Active Record…","html":"<p>The Enumerable module can be used for all of your Ruby classes as long as they implement their own each method. A good example of this are the Active Record Collection Objects. The Rails team has each defined in ActiveRecord.</p>\n<h3>each</h3>\n<p><code class=\"language-text\">#each</code> can be implemented on any object and what it does is it iterates through a collection and performs the block on each element of the collection.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">User.all.each { |user| puts user.email }\ncharlesdmassry@gmail.com\nwombat@example.com</code></pre></div>\n<p>For every method in Enumerable, it turns to <code class=\"language-text\">#each</code> for every method and uses each to perform the method.</p>\n<h3>each_cons</h3>\n<p><code class=\"language-text\">#each_cons</code> returns a group of arrays of consecutive indices with the length specified by the number in the parameter. It then performs the block operation on each array.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[1, 2, 3, 4].each_cons(2) { |a| p a }\n[1, 2]\n[2, 3]\n[3, 4]\n\n{ name: 4, age: 5, ssn: 6 }.each_cons(2) { |a| p a }\n[[:name, 4], [:age, 5]]\n[[:age, 5], [:ssn, 6]]</code></pre></div>\n<p>One collection is turned into an array that contains the number of objects in an argument and performs the operation of the block on each array.</p>\n<h3>each_entry</h3>\n<p><code class=\"language-text\">#each_entry</code> you can just use <code class=\"language-text\">#each</code> for similar results.</p>\n<h3>each_slice</h3>\n<p><code class=\"language-text\">#each_slice</code> takes an argument and similar to <code class=\"language-text\">#each_cons</code>, performs an operation on a new sub-array. This method however, doesn’t make consecutive arrays but makes slices of arrays.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[1, 2, 3, 4].each_cons(2) { |a| p a }\n[1, 2]\n[3, 4]\n\n{ name: 4, age: 5, ssn: 6 }.each_cons(2) { |a| p a }\n[[:name, 4], [:age, 5]]\n[[:ssn, 6]]</code></pre></div>\n<p>Here you can see it can return an uneven output for mismatched elements.</p>\n<h3>each<em>with</em>index</h3>\n<p><code class=\"language-text\">#each_with_index</code> performs each on the collection and also keeps track of the current index.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">user = []\n%w(name age ssn).each_with_index do |element, index|\n    user &lt;&lt; element * index\nend\n[&quot;&quot;, &quot;age&quot;, &quot;ssnssn&quot;]</code></pre></div>\n<p>It can be used for a lot more complicated operations that this and will make your code a lot nicer that this.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">user = []\ncount = 0\n%w(name age ssn).each do |element|\n    user &lt;&lt; element\n    count += 1\nend</code></pre></div>\n<h3>each<em>with</em>object</h3>\n<p><code class=\"language-text\">#each_with_object</code> works by taking a block and a parameter and performing the block operation on the current element and the parameter.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(1..3).each_with_object([]) { |a, i| p a, i }\n1\n[]\n2\n[]\n3\n[]</code></pre></div>\n<p>This method can be used almost identically to <code class=\"language-text\">#each</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">numbers = [1,2,6]\n(1..3).each_with_object(numbers) { |a, i| i &lt;&lt; a } #=&gt; [1, 2, 6, 1, 2, 3]</code></pre></div>\n<p>The second element in the block argument here is the parameter.</p>\n<h3>entries</h3>\n<p><code class=\"language-text\">#entries</code> can be used as an alias for <code class=\"language-text\">#to_a</code>. In some instances, it reads a little bit better than <code class=\"language-text\">#to_a</code>.</p>\n<h3>find</h3>\n<p><code class=\"language-text\">#find</code> returns the first entry where the block conditions are true. It is aliased to detect.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[1,2,5,7,6].find { |a| a &gt; 5 } #=&gt; 7</code></pre></div>\n<p>As you can see, <code class=\"language-text\">#find</code> returns an a number for the first one it finds, for this example it is 7 and not 6 because of the ordered array, so it breaks out. Generally, it would be a good idea to sort this array first if you are using the find method.</p>\n<h3>find_all</h3>\n<p><code class=\"language-text\">#find_all</code> is similar to <code class=\"language-text\">#find</code> except it returns an array where the given conditions are true.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[1,2,5,7,6].find_all { |a| a &gt; 5 } #=&gt; [7, 6]</code></pre></div>\n<h3>find_index</h3>\n<p><code class=\"language-text\">#find_index</code> returns the index of <code class=\"language-text\">#find</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[1,2,5,7,6].find_index { |a| a &gt; 5 } #=&gt; 3</code></pre></div>\n<p>Here it would find the number 7 and see that it is at index 3 and return that number. Stay tuned for more.</p>","frontmatter":{"title":"Ruby Enumerable, Part 2","date":"August 06, 2014"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/25-ruby-enumerable-part-2/","previous":{"fields":{"slug":"/posts/24-keep-your-queries-dry-with-eager-loading/"},"frontmatter":{"title":"Keep Your Queries DRY with Eager Loading","id":24}},"next":{"fields":{"slug":"/posts/26-you-re-so-vain-you-probably-think-this-url-is-about-you/"},"frontmatter":{"title":"You're so vain, you probably think this URL is about you.","id":26}}}}}