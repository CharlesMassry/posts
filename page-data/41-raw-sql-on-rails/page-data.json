{"componentChunkName":"component---src-templates-blog-post-js","path":"/41-raw-sql-on-rails/","webpackCompilationHash":"d44b419ce58fd4452574","result":{"data":{"site":{"siteMetadata":{"title":"Charlie Massry","author":"Charlie Massry"}},"markdownRemark":{"id":"63b2125a-cd0d-57d5-99a8-c34cdf1704c7","excerpt":"ActiveRecord is fantastic, but sometimes if you are doing complex joins and such, you may need to move away from ActiveRecord and write raw SQL. Consider anâ€¦","html":"<p>ActiveRecord is fantastic, but sometimes if you are doing complex joins and such, you may need to move away from ActiveRecord and write raw SQL. Consider an application where you need to join three tables together with one SQL query. How would you write this in SQL?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">SELECT locations.name AS location_name,\n  locations.street_address,\n  locations.city,\n  locations.state,\n  users.title,\n  users.first_name,\n  users.last_name,\n  rooms.id,\n  rooms.name AS room_name,\n  rooms.room_number,\n  rooms.location_id\n  FROM locations\n  INNER JOIN users\n  ON users.location_id = locations.id\n  INNER JOIN rooms\n  ON rooms.location_id = locations.id\n  WHERE locations.name ILIKE &#39;%Empire%&#39;\n  AND users.last_name ILIKE &#39;%Empire%&#39;;</code></pre></div>\n<p>This is a mouthful but what is going on is pretty straightforward; still a few questions come to mind: how do you turn it into an active record object, how to you make the search dynamic, and how do you prevent SQL injection.</p>\n<p>The answer to the first question is to wrap the SQL statement string so ActiveRecord will know how to understand it.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ActiveRecord::Base.\n  connection.\n  execute(\n  &lt;&lt;-SQL\n    SELECT locations.name AS location_name,\n    locations.street_address,\n    locations.city,\n    locations.state,\n    users.title,\n    users.first_name,\n    users.last_name,\n    rooms.id,\n    rooms.name AS room_name,\n    rooms.room_number,\n    rooms.location_id\n    FROM locations\n    INNER JOIN users\n    ON users.location_id = locations.id\n    INNER JOIN rooms\n    ON rooms.location_id = locations.id\n    WHERE locations.name ILIKE &#39;%Empire%&#39;\n    AND users.last_name ILIKE &#39;%Empire%&#39;;\n  SQL\n  )</code></pre></div>\n<p>This will execute it and return an ActiveRecord Object, but it will not be dynamic. You can just make it dynamic with <code class=\"language-text\">?</code>, but it will be vulnerable to SQL injection, which is not something you <a href=\"http://xkcd.com/327/\">want to do</a>, so you will have to escape it.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def sql_query\n  ActiveRecord::Base.\n    connection.\n    execute(\n      sanitized_sql_statement\n    )\nend\n\ndef sanitized_sql_statement\n  ActiveRecord::Base.send(\n    :sanitize_sql_array,\n    [\n      sql_string,\n      &quot;%#{query}%&quot;,\n      &quot;%#{query}%&quot;\n    ]\n  )\nend\n\ndef sql_statement\n  &lt;&lt;-SQL\n    SELECT locations.name AS location_name,\n      locations.street_address,\n      locations.city,\n      locations.state,\n      users.title,\n      users.first_name,\n      users.last_name,\n      rooms.id,\n      rooms.name AS room_name,\n      rooms.room_number,\n      rooms.location_id\n      FROM locations\n      INNER JOIN users\n      ON users.location_id = locations.id\n      INNER JOIN rooms\n      ON rooms.location_id = locations.id\n      WHERE locations.name ILIKE ?\n      AND users.last_name ILIKE ?;\n  SQL\nend</code></pre></div>\n<p>Of course you can rewrite this in ActiveRecord, but it might not seem as intuitive as the SQL statement.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Location.joins(:users, :rooms).select(\n  &quot;locations.name AS location_name&quot;,\n  &quot;locations.street_address&quot;,\n  &quot;locations.city&quot;,\n  &quot;locations.state&quot;,\n  &quot;users.title&quot;,\n  &quot;users.first_name&quot;,\n  &quot;users.last_name&quot;,\n  &quot;rooms.id&quot;,\n  &quot;rooms.name AS room_name&quot;,\n  &quot;rooms.room_number&quot;,\n  &quot;rooms.location_id&quot;\n).where(\n  &quot;locations.name ILIKE ? users.last_name ILIKE ?&quot;,\n  &quot;%#{query}%&quot;,\n  &quot;%#{query}%\n)</code></pre></div>\n<p>Here you can see that locations is the main table that you are joining with the other tables and you are only returning certain columns. If you did <code class=\"language-text\">select(&quot;*&quot;)</code> you would get everything, including the users encrypted password; you are then performing the search query. One of the main problems I had with this was to know exactly when each particular method was supposed to be called. When you call <code class=\"language-text\">SELECT</code> in SQL it has to be the first statement but in ActiveRecord you are chaining the methods together (and doing what looks like a violation of the <a href=\"http://en.wikipedia.org/wiki/Law_of_Demeter\">Law of Demeter</a>), and the ordering of the methods matter so ActiveRecord can properly construct the SQL query. </p>","frontmatter":{"title":"Raw SQL on Rails","date":"October 15, 2014"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/41-raw-sql-on-rails/","previous":{"fields":{"slug":"/40-mock-external-services-with-a-vcr/"},"frontmatter":{"title":"Mock external services with a VCR","id":40}},"next":{"fields":{"slug":"/42-don-t-use-metaprogramming-when-you-can-just-throw-classes-at-things/"},"frontmatter":{"title":"Don't use Metaprogramming When You Can Just Throw Classes at Things","id":42}}}}}