{"componentChunkName":"component---src-templates-blog-post-js","path":"/40-mock-external-services-with-a-vcr/","webpackCompilationHash":"5f59af403a2cb5cd3f33","result":{"data":{"site":{"siteMetadata":{"title":"Charlie Massry","author":"Charlie Massry"}},"markdownRemark":{"id":"c2c0cca9-1ea5-5f1f-a2d1-d5b5852310e6","excerpt":"When creating an Rails App using TDD, sometimes you will come across the need for an external service, for example, using the Google Maps API. Over the course…","html":"<p>When creating an Rails App using TDD, sometimes you will come across the need for an external service, for example, using the Google Maps API. Over the course of testing, you will find that anything that accesses an external service, takes too long, doesn’t work without internet connection, and adds to your request limit. This can be very problematic if you do programming offline, say on a train, as those tests that use external services will all fail. How to solve this problem and still get your tests to pass can sound complicated at first, but there’s a gem for that.</p>\n<p>We will actually be using two gems for this, one to block the tests from contacting anything but <code class=\"language-text\">localhost</code> and one to grab the response once from the external service and refer to the original response on every subsequent test.</p>\n<p>The first gem is <a href=\"https://github.com/bblimke/webmock\">WebMock</a> to disable HTTP requests. To begin add to your <code class=\"language-text\">Gemfile</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">gem &quot;webmock&quot;</code></pre></div>\n<p>and run</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ bundle install</code></pre></div>\n<p>At the top of <code class=\"language-text\">spec_helper.rb</code>, you will need to add</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">require &quot;webmock/rspec&quot;</code></pre></div>\n<p>WebMock.disable<em>net</em>connect!(allow_localhost: true)</p>\n<p>This inserts WebMock into your tests so now you can’t access any external services and the tests will yell at you when you try with an error message like</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">WebMock::NetConnectNotAllowedError:\nReal HTTP connections are disabled. Unregistered request: GET &quot;http://maps.googleapis.com/maps/api/geocode/json?address=350%205th%20Avenue%20New%20York,%20NY%2010118&amp;language=en&amp;sensor=false&quot; with headers {&#39;Accept&#39;=&gt;&#39;*/*&#39;, &#39;Accept-Encoding&#39;=&gt;&#39;gzip;q=1.0,deflate;q=0.6,identity;q=0.3&#39;, &#39;User-Agent&#39;=&gt;&#39;Ruby&#39;}</code></pre></div>\n<p> You can stub this request with the following snippet:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">stub_request(:get, &quot;http://maps.googleapis.com/maps/api/geocode/json?address=350%205th%20Avenue%20New%20York,%20NY%2010118&amp;language=en&amp;sensor=false&quot;).\n  with(:headers =&gt; {&#39;Accept&#39;=&gt;&#39;*/*&#39;, &#39;Accept-Encoding&#39;=&gt;&#39;gzip;q=1.0,deflate;q=0.6,identity;q=0.3&#39;, &#39;User-Agent&#39;=&gt;&#39;Ruby&#39;}).\n  to_return(:status =&gt; 200, :body =&gt; &quot;&quot;, :headers =&gt; {})\n\nregistered request stubs:\n\nstub_request(:get, &quot;http://maps.googleapis.com/&quot;).\n  with(:headers =&gt; {&#39;Accept&#39;=&gt;&#39;*/*&#39;, &#39;User-Agent&#39;=&gt;&#39;Ruby&#39;})\n\n============================================================</code></pre></div>\n<p>This gem is cool that it tells you how to fix it, but you would have to type out exactly what you want to get from the external service, as it doesn’t know what is supposed to be in the body. Wouldn’t it be cool to just run the test once and all of the response gets copied for later usage. The <a href=\"https://github.com/vcr/vcr\">VCR</a> gem does just that. To get that working, in your <code class=\"language-text\">Gemfile</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">gem &quot;vcr&quot;</code></pre></div>\n<p>and run</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ bundle install</code></pre></div>\n<p>Now we must configure VCR to stop WebMock once to record, and then stub out the request every subsequent time. To configure make a <code class=\"language-text\">vcr_setup.rb</code> file in <code class=\"language-text\">spec/support</code> and you will add the configuration details like</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">require &quot;vcr&quot;\n\nVCR.configure do |c|\n  c.cassette_library_dir = &quot;vcr_cassettes&quot;\n  c.hook_into :webmock\nend</code></pre></div>\n<p>What this is doing is creating a directory called <code class=\"language-text\">vcr_cassettes</code> and creating a response YAML file for each unique request in that directory. Since it is a very modular gem, it allows you to interact with not just WebMock but other gems as well, so we need to tell it which gem we are using.</p>\n<p>When you run the tests it will then tell you where it is failing and give you an idea of how to fix it, but the error message can seem a little unnecessary. All it really wants you to do is every time you are making a request to the same external service, just wrap it in a VCR block. For example,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">describe Location do\n  context &quot;.search&quot; do\n    it &quot;returns a correct search result&quot; do\n      VCR.use_cassette(&quot;geolocate&quot;) do\n        @location = create(:location)\n      end\n\n      expect(Location.search(&quot;Empire State Building&quot;)).to include(@location)\n    end\n  end\nend</code></pre></div>\n<p>The first time you run the test it will contact Google Maps and record the response in a YAML file in <code class=\"language-text\">vcr_cassettes/geolocate.yml</code> and will grab that response on every subsequent test where the name passed in to <code class=\"language-text\">.use_cassette</code> is the same. One thing to note is when you are running an integration test, you only need to wrap whatever creates the location in the <code class=\"language-text\">VCR.use_cassette</code> block, so with Capybara</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">...\nfill_in &quot;Name&quot;, with: location.name\n\nVCR.use_cassette(&quot;geolocate&quot;) do\n  click_button &quot;Add Location&quot;\nend\n...</code></pre></div>\n<p>Your tests will now pass on a plane or a train, almost like you have a cassette player with you.</p>","frontmatter":{"title":"Mock external services with a VCR","date":"October 10, 2014"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/40-mock-external-services-with-a-vcr/","previous":{"fields":{"slug":"/39-devise-guest-user/"},"frontmatter":{"title":"Devise Guest User","id":39}},"next":{"fields":{"slug":"/41-raw-sql-on-rails/"},"frontmatter":{"title":"Raw SQL on Rails","id":41}}}}}